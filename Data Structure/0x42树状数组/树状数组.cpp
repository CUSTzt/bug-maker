//树状数组 BIT 维护序列的前缀和
//对于给定序列a，我们建立一个数组c，其中c[x]保存的是序列a的区间[x-lowbit(x)+1,+x]
//中所有数的和。
//把数组c看成树形结构  见lyd书p201
//有如下性质：
//1.每个内部节点c[x]保存以它为根的子树中所有叶节点的和
//2.每个每部节点c[x]的子节点的个数等于lowbit(x)的位数
//3.除树根外，每个内部节点c[x]的父节点是c[x+lowbit(x)].
//4.树的深度是O(log N)
//查询   O(logN)
#define lowbit(x) (x)&(-x)
int ask(int x){
	int ans = 0; 
	for( ; x; x -= lowbit(x))ans += c[x];
		return ans;
}
//如果要查询序列a 的区间[l,r]中所有数字的和，只需要ask(r) - ask(l-1).


//单点增加
//单点增加时要维护前缀和
//增加a[x]，那么c[x]及其祖先节点所保存的区间和中包含了a[x]，对其c值进行更新    
//复杂度 O(log N)
void add(int x,int y){
	for(; x <= n; x += lowbit(x))c[x] += y ;
}

// 在执行所有操作前，我们需要对树状数组进行初始化————针对原始序列a构造一个树状数组
//O(N logN)
//直接建立一个全为零的数组c，然后对每个位置x执行add(x, a[x])的操作。
//O(N)
//从小到大依次考虑每个节点x，借助lowbit运算扫描它的子节点并求和。 