 /************************************************
 # @Author:      miniLCT
 # @DateTime:    2019-07-16 20:35:57
 # @Description: 打好acm就能和cls一样天天吃小龙虾
 ***********************************************/
#include <bits/stdc++.h>

using namespace std;
#define eps 1e-8
#define close ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
typedef long long ll;
const int maxn = 1e6;
const int INF = 1e9;
const ll linf = 0x3f3f3f3f3f3f3f3f;
const double PI = acos(-1.0);
ll mod = 1e9+7;
int main()
{
	int y,m,d;
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d%d",&y,&m,&d);
        if((m+d)%2==0||(d==30&&(m==9||m==11)))
            puts("YES");
        else
            puts("NO");
    }
    return 0;
}

/*
题意就是给你一个年月日，你可以移动月和日，如果下个月没有当前的天数的时候你就不能移动月，当你刚好移动到11月4日你就赢了，如果你超过了十一月四日你就输了。


这个题就是找规律吧，我们可以倒着分析，从最后的那个点开始，然后慢慢往后退。
最终我们应该到达的是奇数点，即每次我们都需要保证自己走完后另一位所面对的是奇数局势，然后他只能走到偶数点，也就是一开始我们保证自己是偶数点开局就能赢。
但是这种说法是不全面的，对于（9，30）这个点，下一个点还是奇数点（10，1），或者你可以直接走到（10，30），这样就是偶数点
（聪明人都会选择前一种做法，让下一个人面对的局势是必败局），同样对于（11，30），你可以直接走到（12，1），这两个点也是必胜的。
为什么不考虑其他只有30十天的30号，原因是只有（9，30)与（11，30）为奇数开局，并且可以为必胜局。
这样最终 的方案就出来了，只需要算出开局为偶数开局或者为（9，30），（11，30） 两个特殊的日子，就是必胜局，其他的为必败局。
技巧性很强很不好想到///。。
 */