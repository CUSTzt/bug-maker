1 #include<cstdio>
2 #include<cmath>
3 #include<vector>
4 using namespace std;
5 typedef long long ll;
6 // return the sum of p^k for all p <= m, where m is in form floor(n / i)
7 // for m <= sqrt{n}, stored in ssum[m]; for m > sqrt{n} stored in lsum[n / m]
8 // note: if you need all correct value of ssum and lsum, please remove ”mark”
9 // and make ”delta” always be 1
10 inline ll sub_mod(ll x,ll y,ll mod){return(x−y+mod)%mod;}
11 inline ll mul_mod(ll a,ll b,ll mod){
12 if(mod<int(2e9))return a*b%mod;
13 ll k=(ll)((long double)a*b/mod);
14 ll res=a*b−k*mod;
15 res%=mod;
16 if(res<0)res+=mod;
17 return res;
18 }
19 inline ll pow_mod(ll a,ll n,ll m){
20 ll res=1;
21 for(a%=m;n;n>>=1){
22 if(n&1)res=mul_mod(res,a,m);
23 a=mul_mod(a,a,m);
24 }
25 return res;
26 }
27 pair<vector<ll>,vector<ll>>prime_count(ll n,ll k,ll mod){
28 auto pow_sum=[](ll n,ll k,ll mod){
29 if(k==0)return n;
30 if(k==1)return n*(n+1)/2%mod;
31 };
32 const ll v=static_cast<ll>(sqrt(n));
33 vector<ll>ssum(v+1),lsum(v+1);
34 vector<bool>mark(v+1);
35 for(int i=1;i<=v;++i){
36 ssum[i]=pow_sum(i,k,mod)−1;
37 lsum[i]=pow_sum(n/i,k,mod)−1;
38 }
39 for(ll p=2;p<=v;++p){
40 if(ssum[p]==ssum[p−1])continue;
41 ll psum=ssum[p−1],q=p*p,ed=min(v,n/q);
42 ll pk=pow_mod(p,k,mod);
43 int delta=(p&1)+1;
44 for(int i=1;i<=ed;i+=delta)if(!mark[i]){
45 ll d=i*p;
46 if(d<=v){
47 lsum[i]=sub_mod(lsum[i],sub_mod(lsum[d],psum,mod)*pk%mod,mod);
48 }else{
49 lsum[i]=sub_mod(lsum[i],sub_mod(ssum[n/d],psum,mod)*pk%mod,mod);
50 }
51 }
52 for(ll i=q;i<=ed;i+=p*delta)mark[i]=1;
53 for(ll i=v;i>=q;−−i){
54 ssum[i]=sub_mod(ssum[i],sub_mod(ssum[i/p],psum,mod)*pk%mod,mod);
55 }
56 }
57 return {move(ssum),move(lsum)};
58 }
59 int main(){
60 ll n,k,mod;
61 scanf(”%lld%lld%lld”,&n,&k,&mod);
62 auto it=prime_count(n,k,mod);
63 printf(”%lld”,it.second[1]);
64 }
